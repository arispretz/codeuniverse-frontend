/**
 * @fileoverview EditorPanel component.
 * Provides a Monaco-based code editor with linting, autocomplete, and execution capabilities.
 * Integrates backend services for code analysis, suggestions, and execution results.
 *
 * @module components/EditorPanel
 */

import React, { useEffect } from "react";
import { Box, Button, Paper } from "@mui/material";
import MonacoEditor from "@monaco-editor/react";
import * as monaco from "monaco-editor";

import {
  lintCodeService,
  runCodeService,
  autocompleteService,
} from "../services/editorService.js";

/**
 * Language mapping for code execution services.
 * Maps language names to backend language IDs.
 *
 * @constant
 * @type {Object<string, number>}
 */
const languageMap = {
  javascript: 63,
  python: 71,
  cpp: 54,
  java: 62,
};

/**
 * EditorPanel Component
 *
 * @function EditorPanel
 * @param {Object} props - Component props.
 * @param {string} props.code - Current code in the editor.
 * @param {Function} props.setCode - Setter function to update the code.
 * @param {string} props.language - Programming language selected.
 * @param {Object} props.editorRef - Ref object to access the Monaco editor instance.
 * @param {Function} props.showSnackbar - Function to show notifications.
 * @param {Function} props.setExecutionResult - Setter function to update execution results.
 * @returns {JSX.Element} Editor panel component with Monaco editor and controls.
 *
 * @example
 * <EditorPanel
 *   code={sourceCode}
 *   setCode={setSourceCode}
 *   language="javascript"
 *   editorRef={editorRef}
 *   showSnackbar={showSnackbar}
 *   setExecutionResult={setExecutionResult}
 * />
 */
const EditorPanel = ({
  code,
  setCode,
  language,
  editorRef,
  showSnackbar,
  setExecutionResult,
}) => {
  /**
   * Lints code using backend service and displays markers in the editor.
   *
   * @async
   * @function lintCode
   * @param {string} code - Code to lint.
   * @returns {Promise<void>} Resolves when linting markers are applied.
   */
  const lintCode = async (code) => {
    try {
      const data = await lintCodeService(code, language);

      const markers = Array.isArray(data.messages)
        ? data.messages.map((msg) => ({
            startLineNumber: msg.line,
            startColumn: msg.column,
            endLineNumber: msg.endLine || msg.line,
            endColumn: msg.endColumn || msg.column + 1,
            message: msg.message,
            severity:
              msg.severity === "error"
                ? monaco.MarkerSeverity.Error
                : monaco.MarkerSeverity.Warning,
          }))
        : [];

      if (editorRef.current) {
        monaco.editor.setModelMarkers(
          editorRef.current.getModel(),
          "eslint",
          markers
        );
      }
    } catch (error) {
      console.error("‚ùå Error linting code:", error);
      showSnackbar("‚ùå Error analyzing code");
    }
  };

  /**
   * Executes code using backend service and updates execution result.
   *
   * @async
   * @function handleRunCode
   * @returns {Promise<void>} Resolves when execution result is updated.
   */
  const handleRunCode = async () => {
    const languageId = languageMap[language];
    try {
      const data = await runCodeService(code, languageId);
      const output = data.stdout || data.stderr || "No output";
      setExecutionResult(output);
    } catch (error) {
      setExecutionResult(`Execution error: ${error.message}`);
    }
  };

  /**
   * Sets up autocomplete suggestions using backend service.
   *
   * @function setupAutocomplete
   * @param {Object} editor - Monaco editor instance.
   * @param {Object} monacoInstance - Monaco instance.
   * @returns {void}
   */
  const setupAutocomplete = (editor, monacoInstance) => {
    let debounceTimer;

    editor.onDidChangeModelContent(() => {
      const currentCode = editor.getValue();
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        autocompleteCode(currentCode);
      }, 1500);
    });

    monacoInstance.languages.registerCompletionItemProvider(language, {
      provideCompletionItems: async () => {
        try {
          const data = await autocompleteService(editor.getValue(), language);

          return {
            suggestions: [
              {
                label: "üí° AI Suggestion",
                kind: monacoInstance.languages.CompletionItemKind.Snippet,
                insertText: data.suggestion || "",
                documentation: "Generated by AI Assistant",
              },
            ],
          };
        } catch (error) {
          console.error("‚ùå Error fetching autocomplete suggestions:", error);
          return { suggestions: [] };
        }
      },
    });
  };

  /**
   * Fetches autocomplete suggestions and shows them in a snackbar.
   *
   * @async
   * @function autocompleteCode
   * @param {string} code - Current code in editor.
   * @returns {Promise<void>} Resolves when suggestions are fetched and displayed.
   */
  const autocompleteCode = async (code) => {
    try {
      const data = await autocompleteService(code, language);
      if (data.suggestion) {
        showSnackbar("üí° Suggestion: " + data.suggestion.slice(0, 60) + "...");
      }
    } catch (error) {
      console.error("‚ùå Error fetching autocomplete:", error);
    }
  };

  useEffect(() => {
    const handleResize = () => {
      if (editorRef.current) {
        editorRef.current.layout();
      }
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, [editorRef]);

  return (
    <Paper
      elevation={3}
      sx={{
        mt: 2,
        p: 2,
        height: "100%",
        display: "flex",
        flexDirection: "column",
      }}
    >
      <Box sx={{ flex: 1, minHeight: 400 }}>
        <MonacoEditor
          height="100%"
          width="100%"
          language={language}
          value={code}
          onChange={(value) => {
            setCode(value);
            if (["javascript", "python", "cpp", "java"].includes(language)) {
              lintCode(value);
            }
          }}
          onMount={(editor, monacoInstance) => {
            editorRef.current = editor;
            setupAutocomplete(editor, monacoInstance);
            editor.layout();
          }}
          options={{
            theme: "vs-dark",
            automaticLayout: true,
          }}
        />
      </Box>

      <Box textAlign="right" mt={2}>
        <Button variant="contained" onClick={handleRunCode}>
          ‚ñ∂Ô∏è Run Code
        </Button>
      </Box>
    </Paper>
  );
};

export default EditorPanel;
